# -*- coding: utf-8 -*-
"""population-genetics-model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l7-erNZUunfsjmncANLedA9mV5YlZMFL

#Population genetics simulation
"""

import pandas as pd
import random
import copy
import seaborn as sns
import matplotlib.pyplot as plt
import os
import glob
random.seed(462)

"""## Data preprocessing"""

f = open("/content/initial_population.vcf", "r")
x = f.read()
x = x.replace("\t", ",").replace("#", "")
f_csv = open("initial_population.csv", "w")
f_csv.write(x)
f.close()
f_csv.close()

df = pd.read_csv("/content/initial_population.csv")

# create a list of individuals
# each indiv is in form (IND0 in int, [SNP0 ~ SNP9999])
init_indivs = []
i = 0
for column in df.columns[6:]:
    init_indivs.append((i, df[column].to_list()))
    i += 1

num_of_indivs = len(init_indivs)

# small list of indivs with only 100 SNPs
init_indivs_small = []
i = 0
for column in df.columns[6:]:
    init_indivs_small.append((i, df[column].to_list()[:100]))
    i += 1

num_of_indivs = len(init_indivs_small)

"""## Model"""

# fitness functions
# (list of indivs) -> (list of fitness)

# neutral fitness
def neutral_fitness(list_of_indivs):
    list_of_fitness = []
    for indiv in list_of_indivs:
        list_of_fitness.append(1)
    return list_of_fitness


# favor SNP 42 fitness
def favor_SNP_42(list_of_indivs):
    list_of_fitness = []
    for indiv in list_of_indivs:
        if indiv[1][42] == "0|0":
            list_of_fitness.append(1)
        elif indiv[1][42] == "1|0" or indiv[1][42] == "0|1":
            list_of_fitness.append(1.5)
        elif indiv[1][42] == "1|1":
            list_of_fitness.append(2)
    return list_of_fitness


# disfavor SNP 42 fitness
def disfavor_SNP_42(list_of_indivs):
    list_of_fitness = []
    for indiv in list_of_indivs:
        if indiv[1][42] == "0|0":
            list_of_fitness.append(1)
        elif indiv[1][42] == "1|0" or indiv[1][42] == "0|1":
            list_of_fitness.append(0.9)
        elif indiv[1][42] == "1|1":
            list_of_fitness.append(0.8)
    return list_of_fitness

# function to pick n pairs of parents based on some fitness function
# (list of indivs, list of fitness, num of pairs of parents) -> n pairs of parents

def pick_parents(list_of_indivs, list_of_fitness, n_pairs):
    n_pairs_of_parents = []

    for i in range(n_pairs):
        # parent 1
        parent1 = random.choices(list_of_indivs, weights=list_of_fitness, k=1)[0]

        # parent 2
        parent1_index = parent1[0]
        weights = copy.deepcopy(list_of_fitness)
        weights[parent1_index] = 0
        parent2 = random.choices(list_of_indivs, weights=weights, k=1)[0]
        del weights

        n_pairs_of_parents.append((parent1, parent2))

    return n_pairs_of_parents

# function to reproduce
# list n pairs of parents -> list of children

def reproduce(list_of_parents):
    list_of_children = []

    chrom_len = len(list_of_parents[0][0][1])
    child_count = 0

    for pair in list_of_parents:
        parent1, parent2 = pair

        # parent1 chroms
        p1m = ""  # maternal chrom
        p1p = ""  # paternal chrom
        for snp in parent1[1]:
            p1m = p1m + snp[0]
            p1p = p1p + snp[2]

        # parent2 chroms
        p2m = ""  # maternal chrom
        p2p = ""  # paternal chrom
        for snp in parent2[1]:
            p2m = p2m + snp[0]
            p2p = p2p + snp[2]

        # child maternal
        k = random.randrange(0, chrom_len)
        who_go_first = random.randrange(0, 2)
        cm = ""
        if who_go_first == 0:  # p1m goes first before p1p
            cm = cm + p1m[0:k+1] + p1p[k+1:]
        else: # p1p goes first before p1m
            cm = cm + p1p[0:k+1] + p1m[k+1:]

        # child paternal
        k = random.randrange(0, chrom_len)
        who_go_first = random.randrange(0, 2)
        cp = ""
        if who_go_first == 0:  # p2m goes first before p2p
            cp = cp + p2m[0:k+1] + p2p[k+1:]
        else: # p2p goes first before p2m
            cp = cp + p2p[0:k+1] + p2m[k+1:]

        # write child's chromosomes into vcf format
        chroms = []
        for i in range(chrom_len):
            to_append = cm[i] + "|" + cp[i]
            chroms.append(to_append)

        child = (child_count, chroms)
        list_of_children.append(child)

        child_count += 1

    return list_of_children

# function to similate going from generation G to generation G+1
# list of indivs from gen G -> list of indivs from G+1

def gen_plus_one(gen_G_pop, fitness_func):
    list_of_fitness = fitness_func(gen_G_pop)
    n_pairs_of_parents = pick_parents(gen_G_pop, list_of_fitness, len(gen_G_pop))
    new_gen_pop = reproduce(n_pairs_of_parents)
    return new_gen_pop

# model
# (list of initial population, fitness func, num_gen) -> list_of_generations
# start with generation 0, num_gen is the end generation

def simulate_n_gen(init_pop, fitness_func, num_gen):
    cur_pop = init_pop
    list_of_generations = [cur_pop]

    for i in range(num_gen):
        cur_pop = gen_plus_one(cur_pop, fitness_func)
        list_of_generations.append(cur_pop)

    return list_of_generations

# model with files
def simulate_n_gen_file(init_pop, fitness_func, num_gen, dir_path):
    cur_pop = init_pop

    mode = 0o666
    os.mkdir(dir_path, mode)

    title = ""
    title += "indiv"
    for i in range(len(init_indivs[0][1])):
        t = ",SNP" + str(i)
        title += t
    title += "\n"

    path = dir_path + "gen001.csv"
    f = open(path, "w")
    f.write(title)
    for indiv in cur_pop:
        line = str(indiv[0])
        for snp in indiv[1]:
            line += ","
            line += snp
        line += "\n"
        f.write(line)
    f.close()

    for i in range(num_gen):
        cur_pop = gen_plus_one(cur_pop, fitness_func)
        if len(str(i)) == 1:
            filename = "gen00" + str(i) + ".csv"
        elif len(str(i)) == 2:
            filename = "gen0" + str(i) + ".csv"
        else:
            filename = "gen" + str(i) + ".csv"

        path = dir_path + filename
        f = open(path, "w")
        f.write(title)
        for indiv in cur_pop:
            line = str(indiv[0])
            for snp in indiv[1]:
                line += ","
                line += snp
            line += "\n"
            f.write(line)
        f.close()

"""## Question c

For generation 0 and generation 1, calculate:
- number of positions that are homozygous for reference allel
- number of positions that are heterozygous
- number of positions that are homozygous for alternate allel
"""

generations = simulate_n_gen(init_indivs, neutral_fitness, 1)

# generation 0
snp_gen_0 = []
gen = generations[0]
chrom_len = len(init_indivs[0][1])

for i in range(chrom_len):
    homo_ref_count = 0
    hetero_count = 0
    homo_alt_count = 0

    for indiv in gen:
        if indiv[1][i] == "0|0":
            homo_ref_count += 1
        elif indiv[1][i] == "1|0" or indiv[1][i] == "0|1":
            hetero_count += 1
        else:
            homo_alt_count += 1
    snp_gen_0.append((homo_ref_count, hetero_count, homo_alt_count))

# generation 1
snp_gen_1 = []
gen = generations[1]
chrom_len = len(init_indivs[0][1])

for i in range(chrom_len):
    homo_ref_count = 0
    hetero_count = 0
    homo_alt_count = 0

    for indiv in gen:
        if indiv[1][i] == "0|0":
            homo_ref_count += 1
        elif indiv[1][i] == "1|0" or indiv[1][i] == "0|1":
            hetero_count += 1
        else:
            homo_alt_count += 1
    snp_gen_1.append((homo_ref_count, hetero_count, homo_alt_count))

alt_allele_count = 0
extinction_count = 0
for i in range(len(snp_gen_0)):
    if snp_gen_0[i][1] == 1:
        alt_allele_count += 1
    if snp_gen_0[i][1] != 0 and snp_gen_1[i][1] == 0:
        extinction_count += 1

print("Question c alt allele count in gen 0: ", alt_allele_count)
print("Question c extinction count: ", extinction_count)

"""## Question d"""

generations = simulate_n_gen(init_indivs, neutral_fitness, 19)

snp_all_gens = []
chrom_len = len(init_indivs[0][1])

for j in range(len(generations)):

    snp_this_gen = []
    gen = generations[j]

    for i in range(chrom_len):
        homo_ref_count = 0
        hetero_count = 0
        homo_alt_count = 0

        for indiv in gen:
            if indiv[1][i] == "0|0":
                homo_ref_count += 1
            elif indiv[1][i] == "1|0" or indiv[1][i] == "0|1":
                hetero_count += 1
            else:
                homo_alt_count += 1
        snp_this_gen.append((homo_ref_count, hetero_count, homo_alt_count))

    snp_all_gens.append(snp_this_gen)

# create data
x = []
for i in range(20):
    x.append(i)

y = []
for i in range(100):
    y.append([])

for gen in snp_all_gens:
    for i in range(100):
        snp = gen[i]
        freq = (snp[1] + snp[2] * 2)/ (2*num_of_indivs)
        y[i].append(freq)

# plot lines
for y_sub in y:
    plt.plot(x, y_sub)
# plt.legend()
plt.show()

"""## Question e"""

generations = simulate_n_gen_file(init_indivs, neutral_fitness, 1000, "/content/generations2/")

x = []  # generation
for i in range(1000):
    x.append(i)

all_gens_homo_ref = []
all_gens_homo_alt = []

filelist = glob.glob(os.path.join("/content/generations2", '*.csv'))

for infile in sorted(filelist):
    homo_ref_count = 0
    homo_alt_count = 0

    df = pd.read_csv(infile)
    for column in df.columns[1:]:
        snps = df[column].values.tolist()
        if snps.count("0|0") == 100:
            homo_ref_count += 1
        elif snps.count("1|1") == 100:
            homo_alt_count += 1
    all_gens_homo_ref.append(homo_ref_count)
    all_gens_homo_alt.append(homo_alt_count)

# plot lines
y = []
for y_sub in all_gens_homo_ref:
    y.append(y_sub/10000)
plt.plot(x, y, label = "extinction")
# plt.plot(x, all_gens_homo_alt, label = "fixation")
plt.legend()
plt.show()

y = []
for y_sub in all_gens_homo_alt:
    y.append(y_sub/10000)
plt.plot(x, y, label = "fixation")
plt.legend()
plt.show()

"""## Question f"""

for i in range(10):
    generations = simulate_n_gen(init_indivs, favor_SNP_42, 1)
    gen = generations[1]

    homo_ref_count = 0
    for indiv in gen:
        if indiv[1][42] == "0|0":
            homo_ref_count += 1

    print("Simulation ", i, ": ", homo_ref_count)

"""# Question g"""

homo_ref_counts = []
homo_alt_counts = []

for i in range(1000):
    generations = simulate_n_gen(init_indivs_small, favor_SNP_42, 99)

    homo_ref_count = 0
    homo_alt_count = 0

    for indiv in generations[99]:
        if indiv[1][42] == "0|0":
            homo_ref_count += 1
        elif indiv[1][42] == "1|1":
            homo_alt_count += 1

    homo_ref_counts.append(homo_ref_count)
    homo_alt_counts.append(homo_alt_count)

print("Out of 1000 simulations, the number of simulations where SNP42 goes extinct: ", homo_ref_counts.count(100))

print("Out of 1000 simulations, the number of simulations where SNP42 fixates: ", homo_alt_counts.count(100))

"""# Question h"""

homo_ref_counts = []
homo_alt_counts = []

for i in range(1000):
    generations = simulate_n_gen(init_indivs_small, disfavor_SNP_42, 99)

    homo_ref_count = 0
    homo_alt_count = 0

    for indiv in generations[99]:
        if indiv[1][42] == "0|0":
            homo_ref_count += 1
        elif indiv[1][42] == "1|1":
            homo_alt_count += 1

    homo_ref_counts.append(homo_ref_count)
    homo_alt_counts.append(homo_alt_count)

print("Out of 1000 simulations, the number of simulations where SNP42 goes extinct: ", homo_ref_counts.count(100))

print("Out of 1000 simulations, the number of simulations where SNP42 fixates: ", homo_alt_counts.count(100))