# -*- coding: utf-8 -*-
"""COMP462-A1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dSS3Xtnjon7z0wAka4cQko8qb1yi-Pkt
"""

import subprocess
import sys

def install(package):
    subprocess.check_call([sys.executable, "-m", "pip", "install", package])

install("Bio")

from Bio.SeqIO.FastaIO import SimpleFastaParser

"""# Dynamic programming code"""

def global_alignment(seqs_file, match_score, mismatch_score, cs, cn):

    # Obtain the two sequences
    seqs = []
    with open(seqs_file) as handle:
        for values in SimpleFastaParser(handle):
            seqs.append(values)

    S = "-" + seqs[0][1]
    T = "-" + seqs[1][1]

    # Obtain the sequence lengths to build a matrix of (m+1) by (n+1)
    m, n = len(S), len(T)
    X = []
    X.clear()

    for i in range(m):
        new_row = []
        for j in range(n):
            new_row.append(0)  # 0 as default value
        X.append(new_row)

    # Initialize the matrix, each cell is a tuple of (value, direction)
    # direction can be left, up, or diagonal, denoted as "l", "u", "d"
    X[0][0] = (0, "")
    X[0][1] = (cs, "l")
    X[1][0] = (cs, "u")

    for i in range(2, m):
        if S[i] == S[i-1]:
            X[i][0] = (X[i-1][0][0] + cs, "u")
        else:
            X[i][0] = (X[i-1][0][0] + cn, "u")

    for j in range(2, n):
        if T[j] == T[j-1]:
            X[0][j] = (X[0][j-1][0] + cs, "l")
        else:
            X[0][j] = (X[0][j-1][0] + cn, "l")

    # Fill the matrix
    for i in range(1, m):
        for j in range(1, n):
            candidates = []

            # The diagonal arrow alignment
            if S[i] == T[j]:
                candidates.append((X[i-1][j-1][0] + match_score, "d"))
            elif S[i] != T[j]:
                candidates.append((X[i-1][j-1][0] + mismatch_score, "d"))

            # The up alignment arrow
            if S[i-1] == S[i]:
                candidates.append((X[i-1][j][0] + cs, "u"))
            elif S[i-1] != S[i]:
                candidates.append((X[i-1][j][0] + cn, "u"))

            # The left alignment arrow
            if T[j-1] == T[j]:
                candidates.append((X[i][j-1][0] + cs, "l"))
            elif T[j-1] != T[j]:
                candidates.append((X[i][j-1][0] + cn, "l"))

            X[i][j] = max(candidates)

    # Trace back
    opt_aln_S = ""
    opt_aln_T = ""

    cur_cell = X[i][j]
    i = m - 1
    j = n - 1

    while cur_cell[1]:
        if cur_cell[1] == 'd':
            opt_aln_S = S[i] + opt_aln_S
            opt_aln_T = T[j] + opt_aln_T
            i -= 1
            j -=1
        elif cur_cell[1] == 'u':
            opt_aln_S = S[i] + opt_aln_S
            opt_aln_T = "-" + opt_aln_T
            i -= 1
        else:
            opt_aln_S = "-" + opt_aln_S
            opt_aln_T  = T[j] + opt_aln_T
            j -=1
        cur_cell = X[i][j]

    # Print the results
    print("Optimal alignment score: " + str(X[m-1][n-1][0]))
    print()
    print("Optimal alignment:")
    print()
    print("\t" + seqs[0][0] + ": " + opt_aln_S)
    print("\t" + seqs[1][0] + ": " + opt_aln_T)
    print()

"""# Examples"""

ex1 = "/example1.fa.txt"
ex2 = "/example2.fa.txt"

# For example 1
global_alignment("/example1.fa.txt", 1, -1, -1, -2)

# For example 2
global_alignment("/example2.fa.txt", 1, -1, -1, -2)